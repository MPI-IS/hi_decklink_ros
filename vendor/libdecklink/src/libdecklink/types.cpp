/*
 *  WARNING: This file is generated by 'enum2str'. Any changes made here will
 *  be destroyed next time the tool is run.
 *
 *  @date: 2018-03-29 15:14:04.311960
 */

#include <stdexcept>



#include "libdecklink/types.hpp"


std::string to_string(DeckLink::ImageFormat value) {
    switch(value) {
    case DeckLink::ImageFormat::NTSC:
        return "NTSC";
    case DeckLink::ImageFormat::NTSC2398:
        return "NTSC2398";
    case DeckLink::ImageFormat::PAL:
        return "PAL";
    case DeckLink::ImageFormat::PALp:
        return "PALp";
    case DeckLink::ImageFormat::HD720p50:
        return "HD720p50";
    case DeckLink::ImageFormat::HD720p5994:
        return "HD720p5994";
    case DeckLink::ImageFormat::HD720p60:
        return "HD720p60";
    case DeckLink::ImageFormat::HD1080p2398:
        return "HD1080p2398";
    case DeckLink::ImageFormat::HD1080p24:
        return "HD1080p24";
    case DeckLink::ImageFormat::HD1080p25:
        return "HD1080p25";
    case DeckLink::ImageFormat::HD1080p2997:
        return "HD1080p2997";
    case DeckLink::ImageFormat::HD1080p30:
        return "HD1080p30";
    case DeckLink::ImageFormat::HD1080i50:
        return "HD1080i50";
    case DeckLink::ImageFormat::HD1080i5994:
        return "HD1080i5994";
    case DeckLink::ImageFormat::HD1080i6000:
        return "HD1080i6000";
    case DeckLink::ImageFormat::HD1080p50:
        return "HD1080p50";
    case DeckLink::ImageFormat::HD1080p5994:
        return "HD1080p5994";
    case DeckLink::ImageFormat::HD1080p6000:
        return "HD1080p6000";
    case DeckLink::ImageFormat::UHD2k2398:
        return "UHD2k2398";
    case DeckLink::ImageFormat::UHD2k24:
        return "UHD2k24";
    case DeckLink::ImageFormat::UHD2k25:
        return "UHD2k25";
    case DeckLink::ImageFormat::UHD2kDCI2398:
        return "UHD2kDCI2398";
    case DeckLink::ImageFormat::UHD2kDCI24:
        return "UHD2kDCI24";
    case DeckLink::ImageFormat::UHD2kDCI25:
        return "UHD2kDCI25";
    case DeckLink::ImageFormat::UHD4k2160p2398:
        return "UHD4k2160p2398";
    case DeckLink::ImageFormat::UHD4k2160p24:
        return "UHD4k2160p24";
    case DeckLink::ImageFormat::UHD4k2160p25:
        return "UHD4k2160p25";
    case DeckLink::ImageFormat::UHD4k2160p2997:
        return "UHD4k2160p2997";
    case DeckLink::ImageFormat::UHD4k2160p30:
        return "UHD4k2160p30";
    case DeckLink::ImageFormat::UHD4k2160p50:
        return "UHD4k2160p50";
    case DeckLink::ImageFormat::UHD4k2160p5994:
        return "UHD4k2160p5994";
    case DeckLink::ImageFormat::UHD4k2160p60:
        return "UHD4k2160p60";
    case DeckLink::ImageFormat::UHD4kDCI2160p2398:
        return "UHD4kDCI2160p2398";
    case DeckLink::ImageFormat::UHD4kDCI2160p24:
        return "UHD4kDCI2160p24";
    case DeckLink::ImageFormat::UHD4kDCI2160p25:
        return "UHD4kDCI2160p25";
    case DeckLink::ImageFormat::Unknown:
        return "Unknown";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::ImageFormat value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    ImageFormat to_ImageFormat(const std::string & value) {
        if (value == "NTSC")
            return ImageFormat::NTSC;
        else if (value == "NTSC2398")
            return ImageFormat::NTSC2398;
        else if (value == "PAL")
            return ImageFormat::PAL;
        else if (value == "PALp")
            return ImageFormat::PALp;
        else if (value == "HD720p50")
            return ImageFormat::HD720p50;
        else if (value == "HD720p5994")
            return ImageFormat::HD720p5994;
        else if (value == "HD720p60")
            return ImageFormat::HD720p60;
        else if (value == "HD1080p2398")
            return ImageFormat::HD1080p2398;
        else if (value == "HD1080p24")
            return ImageFormat::HD1080p24;
        else if (value == "HD1080p25")
            return ImageFormat::HD1080p25;
        else if (value == "HD1080p2997")
            return ImageFormat::HD1080p2997;
        else if (value == "HD1080p30")
            return ImageFormat::HD1080p30;
        else if (value == "HD1080i50")
            return ImageFormat::HD1080i50;
        else if (value == "HD1080i5994")
            return ImageFormat::HD1080i5994;
        else if (value == "HD1080i6000")
            return ImageFormat::HD1080i6000;
        else if (value == "HD1080p50")
            return ImageFormat::HD1080p50;
        else if (value == "HD1080p5994")
            return ImageFormat::HD1080p5994;
        else if (value == "HD1080p6000")
            return ImageFormat::HD1080p6000;
        else if (value == "UHD2k2398")
            return ImageFormat::UHD2k2398;
        else if (value == "UHD2k24")
            return ImageFormat::UHD2k24;
        else if (value == "UHD2k25")
            return ImageFormat::UHD2k25;
        else if (value == "UHD2kDCI2398")
            return ImageFormat::UHD2kDCI2398;
        else if (value == "UHD2kDCI24")
            return ImageFormat::UHD2kDCI24;
        else if (value == "UHD2kDCI25")
            return ImageFormat::UHD2kDCI25;
        else if (value == "UHD4k2160p2398")
            return ImageFormat::UHD4k2160p2398;
        else if (value == "UHD4k2160p24")
            return ImageFormat::UHD4k2160p24;
        else if (value == "UHD4k2160p25")
            return ImageFormat::UHD4k2160p25;
        else if (value == "UHD4k2160p2997")
            return ImageFormat::UHD4k2160p2997;
        else if (value == "UHD4k2160p30")
            return ImageFormat::UHD4k2160p30;
        else if (value == "UHD4k2160p50")
            return ImageFormat::UHD4k2160p50;
        else if (value == "UHD4k2160p5994")
            return ImageFormat::UHD4k2160p5994;
        else if (value == "UHD4k2160p60")
            return ImageFormat::UHD4k2160p60;
        else if (value == "UHD4kDCI2160p2398")
            return ImageFormat::UHD4kDCI2160p2398;
        else if (value == "UHD4kDCI2160p24")
            return ImageFormat::UHD4kDCI2160p24;
        else if (value == "UHD4kDCI2160p25")
            return ImageFormat::UHD4kDCI2160p25;
        else if (value == "Unknown")
            return ImageFormat::Unknown;

        throw std::out_of_range(value);
    }

    namespace ImageFormat_ {

        std::string pretty_print(ImageFormat value) {
            if (value == ImageFormat::NTSC)
                return "525i59.94 NTSC";
            else if (value == ImageFormat::NTSC2398)
                return "525i47.96 NTSC";
            else if (value == ImageFormat::PAL)
                return "625i50 PAL";
            else if (value == ImageFormat::PALp)
                return "625p25 PAL";
            else if (value == ImageFormat::HD720p50)
                return "720p50";
            else if (value == ImageFormat::HD720p5994)
                return "720p59.94";
            else if (value == ImageFormat::HD720p60)
                return "720p60";
            else if (value == ImageFormat::HD1080p2398)
                return "1080p23.98";
            else if (value == ImageFormat::HD1080p24)
                return "1080p24";
            else if (value == ImageFormat::HD1080p25)
                return "1080p25";
            else if (value == ImageFormat::HD1080p2997)
                return "1080p29.97";
            else if (value == ImageFormat::HD1080p30)
                return "1080p30";
            else if (value == ImageFormat::HD1080i50)
                return "1080i50";
            else if (value == ImageFormat::HD1080i5994)
                return "1080i59.94";
            else if (value == ImageFormat::HD1080i6000)
                return "1080i60";
            else if (value == ImageFormat::HD1080p50)
                return "1080p50";
            else if (value == ImageFormat::HD1080p5994)
                return "1080p59.94";
            else if (value == ImageFormat::HD1080p6000)
                return "1080p60";
            else if (value == ImageFormat::UHD2k2398)
                return "2160p23.98";
            else if (value == ImageFormat::UHD2k24)
                return "2160p24";
            else if (value == ImageFormat::UHD2k25)
                return "2160p25";
            else if (value == ImageFormat::UHD2kDCI2398)
                return "2K DCI 23.98p";
            else if (value == ImageFormat::UHD2kDCI24)
                return "2K DCI 24p";
            else if (value == ImageFormat::UHD2kDCI25)
                return "2K DCI 25p";
            else if (value == ImageFormat::UHD4k2160p2398)
                return "4K 2160p23.98";
            else if (value == ImageFormat::UHD4k2160p24)
                return "4K 2160p24";
            else if (value == ImageFormat::UHD4k2160p25)
                return "4K 2160p25";
            else if (value == ImageFormat::UHD4k2160p2997)
                return "4K 2160p29.97";
            else if (value == ImageFormat::UHD4k2160p30)
                return "4K 2160p30";
            else if (value == ImageFormat::UHD4k2160p50)
                return "4K 2160p50";
            else if (value == ImageFormat::UHD4k2160p5994)
                return "4K 2160p59.94";
            else if (value == ImageFormat::UHD4k2160p60)
                return "4K 2160p60";
            else if (value == ImageFormat::UHD4kDCI2160p2398)
                return "4K DCI 23.98p";
            else if (value == ImageFormat::UHD4kDCI2160p24)
                return "4K DCI 24p";
            else if (value == ImageFormat::UHD4kDCI2160p25)
                return "4K DCI 25p";
            else if (value == ImageFormat::Unknown)
                return "Unknown";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<ImageFormat>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::PixelFormat value) {
    switch(value) {
    case DeckLink::PixelFormat::Unknown:
        return "Unknown";
    case DeckLink::PixelFormat::YUV_8Bit:
        return "YUV_8Bit";
    case DeckLink::PixelFormat::YUV_10Bit:
        return "YUV_10Bit";
    case DeckLink::PixelFormat::ARGB_8Bit:
        return "ARGB_8Bit";
    case DeckLink::PixelFormat::BGRA_8Bit:
        return "BGRA_8Bit";
    case DeckLink::PixelFormat::RGB_10Bit:
        return "RGB_10Bit";
    case DeckLink::PixelFormat::RGB_12Bit:
        return "RGB_12Bit";
    case DeckLink::PixelFormat::RGBLE_12Bit:
        return "RGBLE_12Bit";
    case DeckLink::PixelFormat::RGBXLE_10Bit:
        return "RGBXLE_10Bit";
    case DeckLink::PixelFormat::RGBX_10Bit:
        return "RGBX_10Bit";
    case DeckLink::PixelFormat::H265:
        return "H265";
    case DeckLink::PixelFormat::DNxHR:
        return "DNxHR";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::PixelFormat value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    PixelFormat to_PixelFormat(const std::string & value) {
        if (value == "Unknown")
            return PixelFormat::Unknown;
        else if (value == "YUV_8Bit")
            return PixelFormat::YUV_8Bit;
        else if (value == "YUV_10Bit")
            return PixelFormat::YUV_10Bit;
        else if (value == "ARGB_8Bit")
            return PixelFormat::ARGB_8Bit;
        else if (value == "BGRA_8Bit")
            return PixelFormat::BGRA_8Bit;
        else if (value == "RGB_10Bit")
            return PixelFormat::RGB_10Bit;
        else if (value == "RGB_12Bit")
            return PixelFormat::RGB_12Bit;
        else if (value == "RGBLE_12Bit")
            return PixelFormat::RGBLE_12Bit;
        else if (value == "RGBXLE_10Bit")
            return PixelFormat::RGBXLE_10Bit;
        else if (value == "RGBX_10Bit")
            return PixelFormat::RGBX_10Bit;
        else if (value == "H265")
            return PixelFormat::H265;
        else if (value == "DNxHR")
            return PixelFormat::DNxHR;

        throw std::out_of_range(value);
    }

    namespace PixelFormat_ {

        std::string pretty_print(PixelFormat value) {
            if (value == PixelFormat::Unknown)
                return "Unknown";
            else if (value == PixelFormat::YUV_8Bit)
                return "8-bit YUV";
            else if (value == PixelFormat::YUV_10Bit)
                return "10-bit YUV";
            else if (value == PixelFormat::ARGB_8Bit)
                return "8-bit ARGB";
            else if (value == PixelFormat::BGRA_8Bit)
                return "8-bit BGRA";
            else if (value == PixelFormat::RGB_10Bit)
                return "10-bit RGB";
            else if (value == PixelFormat::RGB_12Bit)
                return "12-bit RGB";
            else if (value == PixelFormat::RGBLE_12Bit)
                return "12-bit RGBLE";
            else if (value == PixelFormat::RGBXLE_10Bit)
                return "10-bit RGBXLE";
            else if (value == PixelFormat::RGBX_10Bit)
                return "10-bit RGBX";
            else if (value == PixelFormat::H265)
                return "H.265";
            else if (value == PixelFormat::DNxHR)
                return "DNxHR";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<PixelFormat>::type>(value)
                )
            );
        }
    
        int get_depth(PixelFormat value) {
            if (value == PixelFormat::Unknown)
                return -1;
            else if (value == PixelFormat::YUV_8Bit)
                return -1;
            else if (value == PixelFormat::YUV_10Bit)
                return -1;
            else if (value == PixelFormat::ARGB_8Bit)
                return -1;
            else if (value == PixelFormat::BGRA_8Bit)
                return 4;
            else if (value == PixelFormat::RGB_10Bit)
                return -1;
            else if (value == PixelFormat::RGB_12Bit)
                return -1;
            else if (value == PixelFormat::RGBLE_12Bit)
                return -1;
            else if (value == PixelFormat::RGBXLE_10Bit)
                return -1;
            else if (value == PixelFormat::RGBX_10Bit)
                return -1;
            else if (value == PixelFormat::H265)
                return -1;
            else if (value == PixelFormat::DNxHR)
                return -1;
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<PixelFormat>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::FieldDominance value) {
    switch(value) {
    case DeckLink::FieldDominance::Unknown:
        return "Unknown";
    case DeckLink::FieldDominance::LowerFieldFirst:
        return "LowerFieldFirst";
    case DeckLink::FieldDominance::UpperFieldFirst:
        return "UpperFieldFirst";
    case DeckLink::FieldDominance::Progressive:
        return "Progressive";
    case DeckLink::FieldDominance::ProgressiveSegmented:
        return "ProgressiveSegmented";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::FieldDominance value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    FieldDominance to_FieldDominance(const std::string & value) {
        if (value == "Unknown")
            return FieldDominance::Unknown;
        else if (value == "LowerFieldFirst")
            return FieldDominance::LowerFieldFirst;
        else if (value == "UpperFieldFirst")
            return FieldDominance::UpperFieldFirst;
        else if (value == "Progressive")
            return FieldDominance::Progressive;
        else if (value == "ProgressiveSegmented")
            return FieldDominance::ProgressiveSegmented;

        throw std::out_of_range(value);
    }

    namespace FieldDominance_ {

        std::string get_description(FieldDominance value) {
            if (value == FieldDominance::Unknown)
                return "Indeterminate field dominance.";
            else if (value == FieldDominance::LowerFieldFirst)
                return "Indeterminate field dominance.";
            else if (value == FieldDominance::UpperFieldFirst)
                return "The first frame starts with the upper field (the top scan line).";
            else if (value == FieldDominance::Progressive)
                return "A complete frame containing all scan lines.";
            else if (value == FieldDominance::ProgressiveSegmented)
                return "A progressive frame encoded as a PsF";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<FieldDominance>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::VideoInputFlags value) {
    switch(value) {
    case DeckLink::VideoInputFlags::Default:
        return "Default";
    case DeckLink::VideoInputFlags::EnableFormatDetection:
        return "EnableFormatDetection";
    case DeckLink::VideoInputFlags::DualStream3D:
        return "DualStream3D";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::VideoInputFlags value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    VideoInputFlags to_VideoInputFlags(const std::string & value) {
        if (value == "Default")
            return VideoInputFlags::Default;
        else if (value == "EnableFormatDetection")
            return VideoInputFlags::EnableFormatDetection;
        else if (value == "DualStream3D")
            return VideoInputFlags::DualStream3D;

        throw std::out_of_range(value);
    }

    namespace VideoInputFlags_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::VideoOutputFlags value) {
    switch(value) {
    case DeckLink::VideoOutputFlags::Default:
        return "Default";
    case DeckLink::VideoOutputFlags::VANC:
        return "VANC";
    case DeckLink::VideoOutputFlags::VITC:
        return "VITC";
    case DeckLink::VideoOutputFlags::RP188:
        return "RP188";
    case DeckLink::VideoOutputFlags::DualStream3D:
        return "DualStream3D";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::VideoOutputFlags value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    VideoOutputFlags to_VideoOutputFlags(const std::string & value) {
        if (value == "Default")
            return VideoOutputFlags::Default;
        else if (value == "VANC")
            return VideoOutputFlags::VANC;
        else if (value == "VITC")
            return VideoOutputFlags::VITC;
        else if (value == "RP188")
            return VideoOutputFlags::RP188;
        else if (value == "DualStream3D")
            return VideoOutputFlags::DualStream3D;

        throw std::out_of_range(value);
    }

    namespace VideoOutputFlags_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::AttributeType value) {
    switch(value) {
    case DeckLink::AttributeType::Flag:
        return "Flag";
    case DeckLink::AttributeType::Int:
        return "Int";
    case DeckLink::AttributeType::Float:
        return "Float";
    case DeckLink::AttributeType::String:
        return "String";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::AttributeType value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    AttributeType to_AttributeType(const std::string & value) {
        if (value == "Flag")
            return AttributeType::Flag;
        else if (value == "Int")
            return AttributeType::Int;
        else if (value == "Float")
            return AttributeType::Float;
        else if (value == "String")
            return AttributeType::String;

        throw std::out_of_range(value);
    }

    namespace AttributeType_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::AttributeID value) {
    switch(value) {
    case DeckLink::AttributeID::SupportsInternalKeying:
        return "SupportsInternalKeying";
    case DeckLink::AttributeID::SupportsExternalKeying:
        return "SupportsExternalKeying";
    case DeckLink::AttributeID::SupportsHDKeying:
        return "SupportsHDKeying";
    case DeckLink::AttributeID::SupportsInputFormatDetection:
        return "SupportsInputFormatDetection";
    case DeckLink::AttributeID::SupportsClockTimingAdjustment:
        return "SupportsClockTimingAdjustment";
    case DeckLink::AttributeID::SupportsFulDuplex:
        return "SupportsFulDuplex";
    case DeckLink::AttributeID::SupportsFullFrameReferenceTimingOffset:
        return "SupportsFullFrameReferenceTimingOffset";
    case DeckLink::AttributeID::SupportsSMPTELevelOutput:
        return "SupportsSMPTELevelOutput";
    case DeckLink::AttributeID::SupportsDualLinkSDI:
        return "SupportsDualLinkSDI";
    case DeckLink::AttributeID::SupportsQuadLinkSDI:
        return "SupportsQuadLinkSDI";
    case DeckLink::AttributeID::SupportsIdleOutput:
        return "SupportsIdleOutput";
    case DeckLink::AttributeID::SupportsDuplexModeConfiguration:
        return "SupportsDuplexModeConfiguration";
    case DeckLink::AttributeID::SupportsHDRMetaData:
        return "SupportsHDRMetaData";
    case DeckLink::AttributeID::HasReferenceInput:
        return "HasReferenceInput";
    case DeckLink::AttributeID::HasSerialPort:
        return "HasSerialPort";
    case DeckLink::AttributeID::HasAnalogVideoOutputGain:
        return "HasAnalogVideoOutputGain";
    case DeckLink::AttributeID::CanOnlyAdjustOverallVideoOutputGain:
        return "CanOnlyAdjustOverallVideoOutputGain";
    case DeckLink::AttributeID::HasVideoInputAntiAliasingFilter:
        return "HasVideoInputAntiAliasingFilter";
    case DeckLink::AttributeID::HasBypass:
        return "HasBypass";
    case DeckLink::AttributeID::HasLTCTimecodeOutput:
        return "HasLTCTimecodeOutput";
    case DeckLink::AttributeID::MaximumAudioChannels:
        return "MaximumAudioChannels";
    case DeckLink::AttributeID::MaximumAnalogAudioChannels:
        return "MaximumAnalogAudioChannels";
    case DeckLink::AttributeID::NumberOfSubDevices:
        return "NumberOfSubDevices";
    case DeckLink::AttributeID::SubDeviceIndex:
        return "SubDeviceIndex";
    case DeckLink::AttributeID::PersistentID:
        return "PersistentID";
    case DeckLink::AttributeID::PairedDevicePersistentID:
        return "PairedDevicePersistentID";
    case DeckLink::AttributeID::DeviceGroupID:
        return "DeviceGroupID";
    case DeckLink::AttributeID::TopologicalID:
        return "TopologicalID";
    case DeckLink::AttributeID::VideoOutputConnections:
        return "VideoOutputConnections";
    case DeckLink::AttributeID::VideoInputConnections:
        return "VideoInputConnections";
    case DeckLink::AttributeID::AudioOutputConnections:
        return "AudioOutputConnections";
    case DeckLink::AttributeID::AudioInputConnections:
        return "AudioInputConnections";
    case DeckLink::AttributeID::VideoIOSupport:
        return "VideoIOSupport";
    case DeckLink::AttributeID::ControlConnections:
        return "ControlConnections";
    case DeckLink::AttributeID::DeviceInterface:
        return "DeviceInterface";
    case DeckLink::AttributeID::VideoInputGainMinimum:
        return "VideoInputGainMinimum";
    case DeckLink::AttributeID::VideoInputGainMaximum:
        return "VideoInputGainMaximum";
    case DeckLink::AttributeID::VideoOutputGainMinimum:
        return "VideoOutputGainMinimum";
    case DeckLink::AttributeID::VideoOutputGainMaximum:
        return "VideoOutputGainMaximum";
    case DeckLink::AttributeID::MicrophoneInputGainMinimum:
        return "MicrophoneInputGainMinimum";
    case DeckLink::AttributeID::MicrophoneInputGainMaximum:
        return "MicrophoneInputGainMaximum";
    case DeckLink::AttributeID::SerialPortDeviceName:
        return "SerialPortDeviceName";
    case DeckLink::AttributeID::VendorName:
        return "VendorName";
    case DeckLink::AttributeID::DisplayName:
        return "DisplayName";
    case DeckLink::AttributeID::ModelName:
        return "ModelName";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::AttributeID value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    AttributeID to_AttributeID(const std::string & value) {
        if (value == "SupportsInternalKeying")
            return AttributeID::SupportsInternalKeying;
        else if (value == "SupportsExternalKeying")
            return AttributeID::SupportsExternalKeying;
        else if (value == "SupportsHDKeying")
            return AttributeID::SupportsHDKeying;
        else if (value == "SupportsInputFormatDetection")
            return AttributeID::SupportsInputFormatDetection;
        else if (value == "SupportsClockTimingAdjustment")
            return AttributeID::SupportsClockTimingAdjustment;
        else if (value == "SupportsFulDuplex")
            return AttributeID::SupportsFulDuplex;
        else if (value == "SupportsFullFrameReferenceTimingOffset")
            return AttributeID::SupportsFullFrameReferenceTimingOffset;
        else if (value == "SupportsSMPTELevelOutput")
            return AttributeID::SupportsSMPTELevelOutput;
        else if (value == "SupportsDualLinkSDI")
            return AttributeID::SupportsDualLinkSDI;
        else if (value == "SupportsQuadLinkSDI")
            return AttributeID::SupportsQuadLinkSDI;
        else if (value == "SupportsIdleOutput")
            return AttributeID::SupportsIdleOutput;
        else if (value == "SupportsDuplexModeConfiguration")
            return AttributeID::SupportsDuplexModeConfiguration;
        else if (value == "SupportsHDRMetaData")
            return AttributeID::SupportsHDRMetaData;
        else if (value == "HasReferenceInput")
            return AttributeID::HasReferenceInput;
        else if (value == "HasSerialPort")
            return AttributeID::HasSerialPort;
        else if (value == "HasAnalogVideoOutputGain")
            return AttributeID::HasAnalogVideoOutputGain;
        else if (value == "CanOnlyAdjustOverallVideoOutputGain")
            return AttributeID::CanOnlyAdjustOverallVideoOutputGain;
        else if (value == "HasVideoInputAntiAliasingFilter")
            return AttributeID::HasVideoInputAntiAliasingFilter;
        else if (value == "HasBypass")
            return AttributeID::HasBypass;
        else if (value == "HasLTCTimecodeOutput")
            return AttributeID::HasLTCTimecodeOutput;
        else if (value == "MaximumAudioChannels")
            return AttributeID::MaximumAudioChannels;
        else if (value == "MaximumAnalogAudioChannels")
            return AttributeID::MaximumAnalogAudioChannels;
        else if (value == "NumberOfSubDevices")
            return AttributeID::NumberOfSubDevices;
        else if (value == "SubDeviceIndex")
            return AttributeID::SubDeviceIndex;
        else if (value == "PersistentID")
            return AttributeID::PersistentID;
        else if (value == "PairedDevicePersistentID")
            return AttributeID::PairedDevicePersistentID;
        else if (value == "DeviceGroupID")
            return AttributeID::DeviceGroupID;
        else if (value == "TopologicalID")
            return AttributeID::TopologicalID;
        else if (value == "VideoOutputConnections")
            return AttributeID::VideoOutputConnections;
        else if (value == "VideoInputConnections")
            return AttributeID::VideoInputConnections;
        else if (value == "AudioOutputConnections")
            return AttributeID::AudioOutputConnections;
        else if (value == "AudioInputConnections")
            return AttributeID::AudioInputConnections;
        else if (value == "VideoIOSupport")
            return AttributeID::VideoIOSupport;
        else if (value == "ControlConnections")
            return AttributeID::ControlConnections;
        else if (value == "DeviceInterface")
            return AttributeID::DeviceInterface;
        else if (value == "VideoInputGainMinimum")
            return AttributeID::VideoInputGainMinimum;
        else if (value == "VideoInputGainMaximum")
            return AttributeID::VideoInputGainMaximum;
        else if (value == "VideoOutputGainMinimum")
            return AttributeID::VideoOutputGainMinimum;
        else if (value == "VideoOutputGainMaximum")
            return AttributeID::VideoOutputGainMaximum;
        else if (value == "MicrophoneInputGainMinimum")
            return AttributeID::MicrophoneInputGainMinimum;
        else if (value == "MicrophoneInputGainMaximum")
            return AttributeID::MicrophoneInputGainMaximum;
        else if (value == "SerialPortDeviceName")
            return AttributeID::SerialPortDeviceName;
        else if (value == "VendorName")
            return AttributeID::VendorName;
        else if (value == "DisplayName")
            return AttributeID::DisplayName;
        else if (value == "ModelName")
            return AttributeID::ModelName;

        throw std::out_of_range(value);
    }

    namespace AttributeID_ {

        AttributeType get_value_type(AttributeID value) {
            if (value == AttributeID::SupportsInternalKeying)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsExternalKeying)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsHDKeying)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsInputFormatDetection)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsClockTimingAdjustment)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsFulDuplex)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsFullFrameReferenceTimingOffset)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsSMPTELevelOutput)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsDualLinkSDI)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsQuadLinkSDI)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsIdleOutput)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsDuplexModeConfiguration)
                return AttributeType::Flag;
            else if (value == AttributeID::SupportsHDRMetaData)
                return AttributeType::Flag;
            else if (value == AttributeID::HasReferenceInput)
                return AttributeType::Flag;
            else if (value == AttributeID::HasSerialPort)
                return AttributeType::Flag;
            else if (value == AttributeID::HasAnalogVideoOutputGain)
                return AttributeType::Flag;
            else if (value == AttributeID::CanOnlyAdjustOverallVideoOutputGain)
                return AttributeType::Flag;
            else if (value == AttributeID::HasVideoInputAntiAliasingFilter)
                return AttributeType::Flag;
            else if (value == AttributeID::HasBypass)
                return AttributeType::Flag;
            else if (value == AttributeID::HasLTCTimecodeOutput)
                return AttributeType::Flag;
            else if (value == AttributeID::MaximumAudioChannels)
                return AttributeType::Int;
            else if (value == AttributeID::MaximumAnalogAudioChannels)
                return AttributeType::Int;
            else if (value == AttributeID::NumberOfSubDevices)
                return AttributeType::Int;
            else if (value == AttributeID::SubDeviceIndex)
                return AttributeType::Int;
            else if (value == AttributeID::PersistentID)
                return AttributeType::Int;
            else if (value == AttributeID::PairedDevicePersistentID)
                return AttributeType::Int;
            else if (value == AttributeID::DeviceGroupID)
                return AttributeType::Int;
            else if (value == AttributeID::TopologicalID)
                return AttributeType::Int;
            else if (value == AttributeID::VideoOutputConnections)
                return AttributeType::Int;
            else if (value == AttributeID::VideoInputConnections)
                return AttributeType::Int;
            else if (value == AttributeID::AudioOutputConnections)
                return AttributeType::Int;
            else if (value == AttributeID::AudioInputConnections)
                return AttributeType::Int;
            else if (value == AttributeID::VideoIOSupport)
                return AttributeType::Int;
            else if (value == AttributeID::ControlConnections)
                return AttributeType::Int;
            else if (value == AttributeID::DeviceInterface)
                return AttributeType::Int;
            else if (value == AttributeID::VideoInputGainMinimum)
                return AttributeType::Float;
            else if (value == AttributeID::VideoInputGainMaximum)
                return AttributeType::Float;
            else if (value == AttributeID::VideoOutputGainMinimum)
                return AttributeType::Float;
            else if (value == AttributeID::VideoOutputGainMaximum)
                return AttributeType::Float;
            else if (value == AttributeID::MicrophoneInputGainMinimum)
                return AttributeType::Float;
            else if (value == AttributeID::MicrophoneInputGainMaximum)
                return AttributeType::Float;
            else if (value == AttributeID::SerialPortDeviceName)
                return AttributeType::String;
            else if (value == AttributeID::VendorName)
                return AttributeType::String;
            else if (value == AttributeID::DisplayName)
                return AttributeType::String;
            else if (value == AttributeID::ModelName)
                return AttributeType::String;
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<AttributeID>::type>(value)
                )
            );
        }
    
        std::string get_explanation(AttributeID value) {
            if (value == AttributeID::SupportsInternalKeying)
                return "True if internal keying is supported on this device.";
            else if (value == AttributeID::SupportsExternalKeying)
                return "True if external keying is supported on this device.";
            else if (value == AttributeID::SupportsHDKeying)
                return "";
            else if (value == AttributeID::SupportsInputFormatDetection)
                return "True if input format detection is supported on this device.";
            else if (value == AttributeID::SupportsClockTimingAdjustment)
                return "True if this device supports clock timing adjustment";
            else if (value == AttributeID::SupportsFulDuplex)
                return "True if the DeckLink device supports capture and playback simultaneously.";
            else if (value == AttributeID::SupportsFullFrameReferenceTimingOffset)
                return "True if the DeckLink device supports genlock offset adjustment wider than +/- 511 pixels.";
            else if (value == AttributeID::SupportsSMPTELevelOutput)
                return "True if SMPTE Level A output is supported on this device.";
            else if (value == AttributeID::SupportsDualLinkSDI)
                return "True if SDI dual-link is supported on this device.";
            else if (value == AttributeID::SupportsQuadLinkSDI)
                return "True if SDI quad-link is supported on this device.";
            else if (value == AttributeID::SupportsIdleOutput)
                return "True if this device supports idle output.";
            else if (value == AttributeID::SupportsDuplexModeConfiguration)
                return "True if the DeckLink device supports duplex mode configuration.";
            else if (value == AttributeID::SupportsHDRMetaData)
                return "True if the device supports transport of HDR metadata.";
            else if (value == AttributeID::HasReferenceInput)
                return "True if the DeckLink device has a genlock reference source input connector.";
            else if (value == AttributeID::HasSerialPort)
                return "True if device has a serial port.";
            else if (value == AttributeID::HasAnalogVideoOutputGain)
                return "True if analog video output gain adjustment is supported on this device.";
            else if (value == AttributeID::CanOnlyAdjustOverallVideoOutputGain)
                return "True if only the overall video output gain can be adjusted. In this case, only the luma gain can be accessed with the IDeckLinkConfiguration interface, and it controls all three gains (luma, chroma blue and chroma red).";
            else if (value == AttributeID::HasVideoInputAntiAliasingFilter)
                return "True if there is an antialising filter on the analog video input of this device.";
            else if (value == AttributeID::HasBypass)
                return "True if this device has loop-through bypass function.";
            else if (value == AttributeID::HasLTCTimecodeOutput)
                return "True if this device has a dedicated LTC input";
            else if (value == AttributeID::MaximumAudioChannels)
                return "The maximum number of embedded audio channels on digital connections supported by this device";
            else if (value == AttributeID::MaximumAnalogAudioChannels)
                return "The maximum number of analog audio channels supported by this device.";
            else if (value == AttributeID::NumberOfSubDevices)
                return "Some DeckLink hardware devices contain multiple independent sub-devices. This attribute will be equal to one for most devices, or two or more on a card with multiple sub-devices.";
            else if (value == AttributeID::SubDeviceIndex)
                return "Some DeckLink hardware devices contain multiple independent sub-devices. This attribute indicates the index of the sub-device, starting from zero.";
            else if (value == AttributeID::PersistentID)
                return "A device specific 32 bit unique identifier.";
            else if (value == AttributeID::PairedDevicePersistentID)
                return "The device specific 32 bit unique identifier of the paired sub-device (If the DeckLink device has paired sub-devices - e.g. the DeckLink Quad 2).";
            else if (value == AttributeID::DeviceGroupID)
                return "A 32 bit identifier used to group sub-devices belonging to the same DeckLink hardware device. Supported if the sub-device supports BMDDeckLinkPersistentID";
            else if (value == AttributeID::TopologicalID)
                return "An identifier for DeckLink devices. This feature is supported on a given device if S_OK is returned. The ID will persist across reboots assuming that devices are not disconnected or moved to a different slot.";
            else if (value == AttributeID::VideoOutputConnections)
                return "The video output connections supported by the hardware. Multiple video output connections can be active simultaneously.";
            else if (value == AttributeID::VideoInputConnections)
                return "The video input connections supported by the hardware";
            else if (value == AttributeID::AudioOutputConnections)
                return "The audio output connections supported by the hardware. Multiple audio output connections can be active simultaneously.";
            else if (value == AttributeID::AudioInputConnections)
                return "The audio input connections supported by the hardware";
            else if (value == AttributeID::VideoIOSupport)
                return "The capture and/or playback capability of the device.";
            else if (value == AttributeID::ControlConnections)
                return "The deck control connections supported by the hardware.";
            else if (value == AttributeID::DeviceInterface)
                return "The active device interface (see BMDDeviceInterface for more information)";
            else if (value == AttributeID::VideoInputGainMinimum)
                return "The minimum video input gain in dB for this device.";
            else if (value == AttributeID::VideoInputGainMaximum)
                return "The maximum video input gain in dB for this device.";
            else if (value == AttributeID::VideoOutputGainMinimum)
                return "The minimum video output gain in dB for this device.";
            else if (value == AttributeID::VideoOutputGainMaximum)
                return "The maximum video output gain in dB for this device.";
            else if (value == AttributeID::MicrophoneInputGainMinimum)
                return "The minimum microphone input gain in dB for this device.";
            else if (value == AttributeID::MicrophoneInputGainMaximum)
                return "The maximum microphone input gain in dB for this device.";
            else if (value == AttributeID::SerialPortDeviceName)
                return "The operating system name of the RS422 serial port on this device.";
            else if (value == AttributeID::VendorName)
                return "Hardware vendor name. Returned as a static string which must not be freed by the caller.";
            else if (value == AttributeID::DisplayName)
                return "The device’s display name. See IDeckLink::GetDisplayName.";
            else if (value == AttributeID::ModelName)
                return "Hardware Model Name. See IDeckLink::GetModelName.";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<AttributeID>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::ConfigurationID value) {
    switch(value) {
    case DeckLink::ConfigurationID::Use1080pNotPsF:
        return "Use1080pNotPsF";
    case DeckLink::ConfigurationID::HDMI3DPackingFormat:
        return "HDMI3DPackingFormat";
    case DeckLink::ConfigurationID::AnalogAudioConsumerLevels:
        return "AnalogAudioConsumerLevels";
    case DeckLink::ConfigurationID::FieldFlickerRemoval:
        return "FieldFlickerRemoval";
    case DeckLink::ConfigurationID::HD1080p24ToHD1080i5994Conversion:
        return "HD1080p24ToHD1080i5994Conversion";
    case DeckLink::ConfigurationID::SDIVideoOutput444:
        return "SDIVideoOutput444";
    case DeckLink::ConfigurationID::BlackVideoOutputDuringCapture:
        return "BlackVideoOutputDuringCapture";
    case DeckLink::ConfigurationID::ReferenceInputTimingOffset:
        return "ReferenceInputTimingOffset";
    case DeckLink::ConfigurationID::CapturePassThroughMode:
        return "CapturePassThroughMode";
    case DeckLink::ConfigurationID::VideoOutputConnection:
        return "VideoOutputConnection";
    case DeckLink::ConfigurationID::VideoOutputConversionMode:
        return "VideoOutputConversionMode";
    case DeckLink::ConfigurationID::AnalogVideoOutputFlags:
        return "AnalogVideoOutputFlags";
    case DeckLink::ConfigurationID::VideoInputConnection:
        return "VideoInputConnection";
    case DeckLink::ConfigurationID::AnalogVideoInputFlags:
        return "AnalogVideoInputFlags";
    case DeckLink::ConfigurationID::VideoInputConversionMode:
        return "VideoInputConversionMode";
    case DeckLink::ConfigurationID::PulldownSequenceInitialTimecodeFrame:
        return "PulldownSequenceInitialTimecodeFrame";
    case DeckLink::ConfigurationID::VANCSourceLine1Mapping:
        return "VANCSourceLine1Mapping";
    case DeckLink::ConfigurationID::VANCSourceLine2Mapping:
        return "VANCSourceLine2Mapping";
    case DeckLink::ConfigurationID::VANCSourceLine3Mapping:
        return "VANCSourceLine3Mapping";
    case DeckLink::ConfigurationID::AudioInputConnection:
        return "AudioInputConnection";
    case DeckLink::ConfigurationID::AnalogAudioInputScaleChannel1:
        return "AnalogAudioInputScaleChannel1";
    case DeckLink::ConfigurationID::AnalogAudioInputScaleChannel2:
        return "AnalogAudioInputScaleChannel2";
    case DeckLink::ConfigurationID::AnalogAudioInputScaleChannel3:
        return "AnalogAudioInputScaleChannel3";
    case DeckLink::ConfigurationID::AnalogAudioInputScaleChannel4:
        return "AnalogAudioInputScaleChannel4";
    case DeckLink::ConfigurationID::DigitalAudioInputScale:
        return "DigitalAudioInputScale";
    case DeckLink::ConfigurationID::AudioOutputAESAnalogSwitch:
        return "AudioOutputAESAnalogSwitch";
    case DeckLink::ConfigurationID::AnalogAudioOutputScaleChannel1:
        return "AnalogAudioOutputScaleChannel1";
    case DeckLink::ConfigurationID::AnalogAudioOutputScaleChannel2:
        return "AnalogAudioOutputScaleChannel2";
    case DeckLink::ConfigurationID::AnalogAudioOutputScaleChannel3:
        return "AnalogAudioOutputScaleChannel3";
    case DeckLink::ConfigurationID::AnalogAudioOutputScaleChannel4:
        return "AnalogAudioOutputScaleChannel4";
    case DeckLink::ConfigurationID::DigitalAudioOutputScale:
        return "DigitalAudioOutputScale";
    case DeckLink::ConfigurationID::DownConversionOnAllAnalogOutput:
        return "DownConversionOnAllAnalogOutput";
    case DeckLink::ConfigurationID::SMPTELevelAOutput:
        return "SMPTELevelAOutput";
    case DeckLink::ConfigurationID::DeviceInformationLabel:
        return "DeviceInformationLabel";
    case DeckLink::ConfigurationID::DeviceInformationSerialNumber:
        return "DeviceInformationSerialNumber";
    case DeckLink::ConfigurationID::DeviceInformationCompany:
        return "DeviceInformationCompany";
    case DeckLink::ConfigurationID::DeviceInformationPhone:
        return "DeviceInformationPhone";
    case DeckLink::ConfigurationID::DeviceInformationEmail:
        return "DeviceInformationEmail";
    case DeckLink::ConfigurationID::DeviceInformationDate:
        return "DeviceInformationDate";
    case DeckLink::ConfigurationID::VideoOutputIdleOperation:
        return "VideoOutputIdleOperation";
    case DeckLink::ConfigurationID::SwapSerialRxTx:
        return "SwapSerialRxTx";
    case DeckLink::ConfigurationID::Bypass:
        return "Bypass";
    case DeckLink::ConfigurationID::ClockTimingAdjustment:
        return "ClockTimingAdjustment";
    case DeckLink::ConfigurationID::VideoInputScanning:
        return "VideoInputScanning";
    case DeckLink::ConfigurationID::UseDedicatedLTCInput:
        return "UseDedicatedLTCInput";
    case DeckLink::ConfigurationID::DefaultVideoOutputMode:
        return "DefaultVideoOutputMode";
    case DeckLink::ConfigurationID::DefaultVideoOutputModeFlags:
        return "DefaultVideoOutputModeFlags";
    case DeckLink::ConfigurationID::SDIOutputLinkConfiguration:
        return "SDIOutputLinkConfiguration";
    case DeckLink::ConfigurationID::VideoOutputComponentLumaGain:
        return "VideoOutputComponentLumaGain";
    case DeckLink::ConfigurationID::VideoOutputComponentChromaBlueGain:
        return "VideoOutputComponentChromaBlueGain";
    case DeckLink::ConfigurationID::VideoOutputComponentChromaRedGain:
        return "VideoOutputComponentChromaRedGain";
    case DeckLink::ConfigurationID::VideoOutputCompositeLumaGain:
        return "VideoOutputCompositeLumaGain";
    case DeckLink::ConfigurationID::VideoOutputCompositeChromaGain:
        return "VideoOutputCompositeChromaGain";
    case DeckLink::ConfigurationID::VideoOutputSVideoLumaGain:
        return "VideoOutputSVideoLumaGain";
    case DeckLink::ConfigurationID::VideoOutputSVideoChromaGain:
        return "VideoOutputSVideoChromaGain";
    case DeckLink::ConfigurationID::VideoInputComponentLumaGain:
        return "VideoInputComponentLumaGain";
    case DeckLink::ConfigurationID::VideoInputComponentChromaBlueGain:
        return "VideoInputComponentChromaBlueGain";
    case DeckLink::ConfigurationID::VideoInputComponentChromaRedGain:
        return "VideoInputComponentChromaRedGain";
    case DeckLink::ConfigurationID::VideoInputCompositeLumaGain:
        return "VideoInputCompositeLumaGain";
    case DeckLink::ConfigurationID::VideoInputCompositeChromaGain:
        return "VideoInputCompositeChromaGain";
    case DeckLink::ConfigurationID::VideoInputSVideoLumaGain:
        return "VideoInputSVideoLumaGain";
    case DeckLink::ConfigurationID::VideoInputSVideoChromaGain:
        return "VideoInputSVideoChromaGain";
    case DeckLink::ConfigurationID::MicrophonePhantomPower:
        return "MicrophonePhantomPower";
    case DeckLink::ConfigurationID::MicrophoneInputGain:
        return "MicrophoneInputGain";
    case DeckLink::ConfigurationID::HeadphoneVolume:
        return "HeadphoneVolume";
    case DeckLink::ConfigurationID::DeckControlConnection:
        return "DeckControlConnection";
    case DeckLink::ConfigurationID::SDIInput3DPayloadOverride:
        return "SDIInput3DPayloadOverride";
    case DeckLink::ConfigurationID::DuplexMode:
        return "DuplexMode";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::ConfigurationID value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    ConfigurationID to_ConfigurationID(const std::string & value) {
        if (value == "Use1080pNotPsF")
            return ConfigurationID::Use1080pNotPsF;
        else if (value == "HDMI3DPackingFormat")
            return ConfigurationID::HDMI3DPackingFormat;
        else if (value == "AnalogAudioConsumerLevels")
            return ConfigurationID::AnalogAudioConsumerLevels;
        else if (value == "FieldFlickerRemoval")
            return ConfigurationID::FieldFlickerRemoval;
        else if (value == "HD1080p24ToHD1080i5994Conversion")
            return ConfigurationID::HD1080p24ToHD1080i5994Conversion;
        else if (value == "SDIVideoOutput444")
            return ConfigurationID::SDIVideoOutput444;
        else if (value == "BlackVideoOutputDuringCapture")
            return ConfigurationID::BlackVideoOutputDuringCapture;
        else if (value == "ReferenceInputTimingOffset")
            return ConfigurationID::ReferenceInputTimingOffset;
        else if (value == "CapturePassThroughMode")
            return ConfigurationID::CapturePassThroughMode;
        else if (value == "VideoOutputConnection")
            return ConfigurationID::VideoOutputConnection;
        else if (value == "VideoOutputConversionMode")
            return ConfigurationID::VideoOutputConversionMode;
        else if (value == "AnalogVideoOutputFlags")
            return ConfigurationID::AnalogVideoOutputFlags;
        else if (value == "VideoInputConnection")
            return ConfigurationID::VideoInputConnection;
        else if (value == "AnalogVideoInputFlags")
            return ConfigurationID::AnalogVideoInputFlags;
        else if (value == "VideoInputConversionMode")
            return ConfigurationID::VideoInputConversionMode;
        else if (value == "PulldownSequenceInitialTimecodeFrame")
            return ConfigurationID::PulldownSequenceInitialTimecodeFrame;
        else if (value == "VANCSourceLine1Mapping")
            return ConfigurationID::VANCSourceLine1Mapping;
        else if (value == "VANCSourceLine2Mapping")
            return ConfigurationID::VANCSourceLine2Mapping;
        else if (value == "VANCSourceLine3Mapping")
            return ConfigurationID::VANCSourceLine3Mapping;
        else if (value == "AudioInputConnection")
            return ConfigurationID::AudioInputConnection;
        else if (value == "AnalogAudioInputScaleChannel1")
            return ConfigurationID::AnalogAudioInputScaleChannel1;
        else if (value == "AnalogAudioInputScaleChannel2")
            return ConfigurationID::AnalogAudioInputScaleChannel2;
        else if (value == "AnalogAudioInputScaleChannel3")
            return ConfigurationID::AnalogAudioInputScaleChannel3;
        else if (value == "AnalogAudioInputScaleChannel4")
            return ConfigurationID::AnalogAudioInputScaleChannel4;
        else if (value == "DigitalAudioInputScale")
            return ConfigurationID::DigitalAudioInputScale;
        else if (value == "AudioOutputAESAnalogSwitch")
            return ConfigurationID::AudioOutputAESAnalogSwitch;
        else if (value == "AnalogAudioOutputScaleChannel1")
            return ConfigurationID::AnalogAudioOutputScaleChannel1;
        else if (value == "AnalogAudioOutputScaleChannel2")
            return ConfigurationID::AnalogAudioOutputScaleChannel2;
        else if (value == "AnalogAudioOutputScaleChannel3")
            return ConfigurationID::AnalogAudioOutputScaleChannel3;
        else if (value == "AnalogAudioOutputScaleChannel4")
            return ConfigurationID::AnalogAudioOutputScaleChannel4;
        else if (value == "DigitalAudioOutputScale")
            return ConfigurationID::DigitalAudioOutputScale;
        else if (value == "DownConversionOnAllAnalogOutput")
            return ConfigurationID::DownConversionOnAllAnalogOutput;
        else if (value == "SMPTELevelAOutput")
            return ConfigurationID::SMPTELevelAOutput;
        else if (value == "DeviceInformationLabel")
            return ConfigurationID::DeviceInformationLabel;
        else if (value == "DeviceInformationSerialNumber")
            return ConfigurationID::DeviceInformationSerialNumber;
        else if (value == "DeviceInformationCompany")
            return ConfigurationID::DeviceInformationCompany;
        else if (value == "DeviceInformationPhone")
            return ConfigurationID::DeviceInformationPhone;
        else if (value == "DeviceInformationEmail")
            return ConfigurationID::DeviceInformationEmail;
        else if (value == "DeviceInformationDate")
            return ConfigurationID::DeviceInformationDate;
        else if (value == "VideoOutputIdleOperation")
            return ConfigurationID::VideoOutputIdleOperation;
        else if (value == "SwapSerialRxTx")
            return ConfigurationID::SwapSerialRxTx;
        else if (value == "Bypass")
            return ConfigurationID::Bypass;
        else if (value == "ClockTimingAdjustment")
            return ConfigurationID::ClockTimingAdjustment;
        else if (value == "VideoInputScanning")
            return ConfigurationID::VideoInputScanning;
        else if (value == "UseDedicatedLTCInput")
            return ConfigurationID::UseDedicatedLTCInput;
        else if (value == "DefaultVideoOutputMode")
            return ConfigurationID::DefaultVideoOutputMode;
        else if (value == "DefaultVideoOutputModeFlags")
            return ConfigurationID::DefaultVideoOutputModeFlags;
        else if (value == "SDIOutputLinkConfiguration")
            return ConfigurationID::SDIOutputLinkConfiguration;
        else if (value == "VideoOutputComponentLumaGain")
            return ConfigurationID::VideoOutputComponentLumaGain;
        else if (value == "VideoOutputComponentChromaBlueGain")
            return ConfigurationID::VideoOutputComponentChromaBlueGain;
        else if (value == "VideoOutputComponentChromaRedGain")
            return ConfigurationID::VideoOutputComponentChromaRedGain;
        else if (value == "VideoOutputCompositeLumaGain")
            return ConfigurationID::VideoOutputCompositeLumaGain;
        else if (value == "VideoOutputCompositeChromaGain")
            return ConfigurationID::VideoOutputCompositeChromaGain;
        else if (value == "VideoOutputSVideoLumaGain")
            return ConfigurationID::VideoOutputSVideoLumaGain;
        else if (value == "VideoOutputSVideoChromaGain")
            return ConfigurationID::VideoOutputSVideoChromaGain;
        else if (value == "VideoInputComponentLumaGain")
            return ConfigurationID::VideoInputComponentLumaGain;
        else if (value == "VideoInputComponentChromaBlueGain")
            return ConfigurationID::VideoInputComponentChromaBlueGain;
        else if (value == "VideoInputComponentChromaRedGain")
            return ConfigurationID::VideoInputComponentChromaRedGain;
        else if (value == "VideoInputCompositeLumaGain")
            return ConfigurationID::VideoInputCompositeLumaGain;
        else if (value == "VideoInputCompositeChromaGain")
            return ConfigurationID::VideoInputCompositeChromaGain;
        else if (value == "VideoInputSVideoLumaGain")
            return ConfigurationID::VideoInputSVideoLumaGain;
        else if (value == "VideoInputSVideoChromaGain")
            return ConfigurationID::VideoInputSVideoChromaGain;
        else if (value == "MicrophonePhantomPower")
            return ConfigurationID::MicrophonePhantomPower;
        else if (value == "MicrophoneInputGain")
            return ConfigurationID::MicrophoneInputGain;
        else if (value == "HeadphoneVolume")
            return ConfigurationID::HeadphoneVolume;
        else if (value == "DeckControlConnection")
            return ConfigurationID::DeckControlConnection;
        else if (value == "SDIInput3DPayloadOverride")
            return ConfigurationID::SDIInput3DPayloadOverride;
        else if (value == "DuplexMode")
            return ConfigurationID::DuplexMode;

        throw std::out_of_range(value);
    }

    namespace ConfigurationID_ {

        std::string get_description(ConfigurationID value) {
            if (value == ConfigurationID::Use1080pNotPsF)
                return "In 1080 or 2K modes use P not PsF if this setting is enabled.";
            else if (value == ConfigurationID::HDMI3DPackingFormat)
                return "The 3D packing format setting. See BMDVideo3DPackingFormat for more details.";
            else if (value == ConfigurationID::AnalogAudioConsumerLevels)
                return "If set true the analog audio levels are set to maximum gain on audio input and maximum attenuation on audio output. If set false the selected analog input and output gain levels are used.";
            else if (value == ConfigurationID::FieldFlickerRemoval)
                return "Sets field flicker removal when paused functionality. True if enabled.";
            else if (value == ConfigurationID::HD1080p24ToHD1080i5994Conversion)
                return "True if HD 1080p24 to HD 1080i5994 conversion is enabled.";
            else if (value == ConfigurationID::SDIVideoOutput444)
                return "True if 444 video output is enabled.";
            else if (value == ConfigurationID::BlackVideoOutputDuringCapture)
                return "True if black output during capture is enabled. This feature is only supported on legacy DeckLink devices";
            else if (value == ConfigurationID::ReferenceInputTimingOffset)
                return "Adjust genlock timing pixel offset. If the device supports wide genlock offset adjustment (see BMDDeckLinkSupportsFullFrameReferenceInputTimingOffset attribute) then the supported range is between +/- half the count of total pixels in the video frame. Otherwise the supported range is +/- 511.";
            else if (value == ConfigurationID::CapturePassThroughMode)
                return "The capture pass through mode specifies how the monitoring video output is generated while capture is in progress. See BMDDeckLinkCapturePassthroughMode for the available modes.";
            else if (value == ConfigurationID::VideoOutputConnection)
                return "The output video connection. See BMDVideoConnection for more details. Enabling video output on one connection will enable output on other available output connections which are compatible. The status of active output connection can be queried with this setting. Multiple video output connections can be active simultaneously. When querying the enabled video outputs, the returned integer is a bitmask of BMDVideoConnection where the corresponding bit is set for each active output connection. When setting active video outputs, only one video output connection can be enabled per call, ie, the integer argument must refer to a single video output connection. Enabling multiple output connections simultaneously requires multiple calls";
            else if (value == ConfigurationID::VideoOutputConversionMode)
                return "Settings for video output conversion. The possible output modes are enumerated by BMDVideoOutputConversionMode.";
            else if (value == ConfigurationID::AnalogVideoOutputFlags)
                return "Settings for analog video output. BMDAnalogVideoFlags enumerates the available analog video flags.";
            else if (value == ConfigurationID::VideoInputConnection)
                return "The input video connection. Only one video input connection can be active at a time. See BMDVideoConnection for more details.";
            else if (value == ConfigurationID::AnalogVideoInputFlags)
                return "The analog video input flags. See BMDAnalogVideoFlags for more details.";
            else if (value == ConfigurationID::VideoInputConversionMode)
                return "The video input conversion mode. See BMDVideoInputConversionMode for more details.";
            else if (value == ConfigurationID::PulldownSequenceInitialTimecodeFrame)
                return "The A-frame setting for NTSC 23.98, which is used to appropriately adjust the timecode. The frame setting range is between 0 and 29.";
            else if (value == ConfigurationID::VANCSourceLine1Mapping)
                return "The configuration of up to three lines of VANC to be transferred to or from the active picture on capture or output. The acceptable range is between 0 and 30. A value of 0 will disable the capture of that line.";
            else if (value == ConfigurationID::VANCSourceLine2Mapping)
                return "The acceptable range is between 0 and 30. A value of 0 will disable the capture of the line.";
            else if (value == ConfigurationID::VANCSourceLine3Mapping)
                return "The acceptable range is between 0 and 30. A value of 0 will disable the capture of the line.";
            else if (value == ConfigurationID::AudioInputConnection)
                return "The configuration of the audio input connection. See BMDAudioConnection for more details.";
            else if (value == ConfigurationID::AnalogAudioInputScaleChannel1)
                return "The analog audio input scale in dB. The supported range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioInputScaleChannel2)
                return "The analog audio input scale in dB. The supported range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioInputScaleChannel3)
                return "The analog audio input scale in dB. The supported range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioInputScaleChannel4)
                return "The analog audio input scale in dB. The supported range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::DigitalAudioInputScale)
                return "The digital audio input scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AudioOutputAESAnalogSwitch)
                return "The AES / analog audio output selection switch. This is applicable only to cards that support switchable analog audio outputs.";
            else if (value == ConfigurationID::AnalogAudioOutputScaleChannel1)
                return "The analog audio output scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioOutputScaleChannel2)
                return "The analog audio output scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioOutputScaleChannel3)
                return "The analog audio output scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::AnalogAudioOutputScaleChannel4)
                return "The analog audio output scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::DigitalAudioOutputScale)
                return "The analog audio output scale in dB. The acceptable range is between -12.00 and 12.00.";
            else if (value == ConfigurationID::DownConversionOnAllAnalogOutput)
                return "Enable down conversion on all analog outputs.";
            else if (value == ConfigurationID::SMPTELevelAOutput)
                return "Enable SMPTE level A output.";
            else if (value == ConfigurationID::DeviceInformationLabel)
                return "Set the label of the device. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::DeviceInformationSerialNumber)
                return "Set the serial number of the device. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::DeviceInformationCompany)
                return "Set the device’s seller name. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::DeviceInformationPhone)
                return "Set the device’s seller phone number. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::DeviceInformationEmail)
                return "Set the device’s seller email address. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::DeviceInformationDate)
                return "Set the device’s purchase date. This can only be set if the device has a persistent ID. This information will be saved onto the local machine but not onto the device. This information will also appear in Product Notes section of the Desktop Video Utility.";
            else if (value == ConfigurationID::VideoOutputIdleOperation)
                return "Video output idle control. See BMDIdleVideoOutputOperation for more details.";
            else if (value == ConfigurationID::SwapSerialRxTx)
                return "If set to true, the Rx and Tx lines of the RS422 port on the DeckLink device will be swapped.";
            else if (value == ConfigurationID::Bypass)
                return "The state of the bypass feature. This parameter can be set to a value of -1 for normal operation or zero to bypass the card. A timeout of up to 65 seconds may be specified in milliseconds. If the timeout is reached without the parameter being reset, the card will be bypassed automatically. The actual timeout will be approximately the time requested.";
            else if (value == ConfigurationID::ClockTimingAdjustment)
                return "Clock frequency adjustment for fine output control. The acceptable range is from -127 to 127 PPM (Parts Per Million).";
            else if (value == ConfigurationID::VideoInputScanning)
                return "The video input connector scanning on the H.264 Pro Recorder. True if enabled.";
            else if (value == ConfigurationID::UseDedicatedLTCInput)
                return "Use the timecode from the LTC input rather than from the SDI stream.";
            else if (value == ConfigurationID::DefaultVideoOutputMode)
                return "The default video output mode. The bmdDeckLinkConfigDefaultVideoOutputModeFlags must be set for 3D video modes before using this setting. See BMDDisplayMode for more details.";
            else if (value == ConfigurationID::DefaultVideoOutputModeFlags)
                return "The default video output mode 2D or 3D flag setting. See bmdVideoOutputFlagDefault and bmdVideoOutputDualStream3D for more details.";
            else if (value == ConfigurationID::SDIOutputLinkConfiguration)
                return "The SDI link configuration for a single output video stream. See BMDLinkConfiguration for more information.";
            else if (value == ConfigurationID::VideoOutputComponentLumaGain)
                return "The component video output luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputComponentChromaBlueGain)
                return "The component video output chroma blue gain in dB.The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputComponentChromaRedGain)
                return "The component video output chroma red gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputCompositeLumaGain)
                return "The composite video output luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputCompositeChromaGain)
                return "The composite video output chroma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputSVideoLumaGain)
                return "The s-video output luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoOutputSVideoChromaGain)
                return "The s-video output chroma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoOutputGainMinimum and BMDDeckLinkVideoOutputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputComponentLumaGain)
                return "The component video input luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputComponentChromaBlueGain)
                return "The component video input chroma blue gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputComponentChromaRedGain)
                return "The component video input chroma red gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputCompositeLumaGain)
                return "The composite video input luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputCompositeChromaGain)
                return "The composite video input chroma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputSVideoLumaGain)
                return "The s-video input luma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::VideoInputSVideoChromaGain)
                return "The s-video input chroma gain in dB. The accepted range can be determined by using the BMDDeckLinkVideoInputGainMinimum and BMDDeckLinkVideoInputGainMaximum attributes with IDeckLinkAttributes interface.";
            else if (value == ConfigurationID::MicrophonePhantomPower)
                return "If set to true, the Microphone input will provide +48V Phantom Power.";
            else if (value == ConfigurationID::MicrophoneInputGain)
                return "The microphone input gain in dB. The acceptable range can be determined via BMDDeckLinkMicrophoneInputGainMinimum and BMDDeckLinkMicrophoneInputGainMaximum. If set to 0dB, the microphone input will be muted.";
            else if (value == ConfigurationID::HeadphoneVolume)
                return "Set the headphone volume, acceptable range is between 0.0 (mute), to 1.0 (full volume)";
            else if (value == ConfigurationID::DeckControlConnection)
                return "The active RS422 deck control connection. See BMDDeckControlConnection for more information.";
            else if (value == ConfigurationID::SDIInput3DPayloadOverride)
                return "If set to true, the device will capture two genlocked SDI streams with matching video modes as a 3D stream";
            else if (value == ConfigurationID::DuplexMode)
                return "The active duplex mode on sub-devices which support duplex mode configuration. See BMDDeckLinkSupportsDuplexModeConfiguration and BMDDuplexMode for more information.";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<ConfigurationID>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::StatusID value) {
    switch(value) {
    case DeckLink::StatusID::DetectedVideoInputMode:
        return "DetectedVideoInputMode";
    case DeckLink::StatusID::DetectedVideoInputFlags:
        return "DetectedVideoInputFlags";
    case DeckLink::StatusID::CurrentVideoInputMode:
        return "CurrentVideoInputMode";
    case DeckLink::StatusID::CurrentVideoInputPixelFormat:
        return "CurrentVideoInputPixelFormat";
    case DeckLink::StatusID::CurrentVideoInputFlags:
        return "CurrentVideoInputFlags";
    case DeckLink::StatusID::CurrentVideoOutputMode:
        return "CurrentVideoOutputMode";
    case DeckLink::StatusID::CurrentVideoOutputFlags:
        return "CurrentVideoOutputFlags";
    case DeckLink::StatusID::PCIExpressLinkWidth:
        return "PCIExpressLinkWidth";
    case DeckLink::StatusID::PCIExpressLinkSpeed:
        return "PCIExpressLinkSpeed";
    case DeckLink::StatusID::LastVideoOutputPixelFormat:
        return "LastVideoOutputPixelFormat";
    case DeckLink::StatusID::ReferenceSignalMode:
        return "ReferenceSignalMode";
    case DeckLink::StatusID::DuplexMode:
        return "DuplexMode";
    case DeckLink::StatusID::BusyState:
        return "BusyState";
    case DeckLink::StatusID::VideoInputSignalLocked:
        return "VideoInputSignalLocked";
    case DeckLink::StatusID::ReferenceSignalLocked:
        return "ReferenceSignalLocked";
    case DeckLink::StatusID::ReferenceSignalFlags:
        return "ReferenceSignalFlags";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::StatusID value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    StatusID to_StatusID(const std::string & value) {
        if (value == "DetectedVideoInputMode")
            return StatusID::DetectedVideoInputMode;
        else if (value == "DetectedVideoInputFlags")
            return StatusID::DetectedVideoInputFlags;
        else if (value == "CurrentVideoInputMode")
            return StatusID::CurrentVideoInputMode;
        else if (value == "CurrentVideoInputPixelFormat")
            return StatusID::CurrentVideoInputPixelFormat;
        else if (value == "CurrentVideoInputFlags")
            return StatusID::CurrentVideoInputFlags;
        else if (value == "CurrentVideoOutputMode")
            return StatusID::CurrentVideoOutputMode;
        else if (value == "CurrentVideoOutputFlags")
            return StatusID::CurrentVideoOutputFlags;
        else if (value == "PCIExpressLinkWidth")
            return StatusID::PCIExpressLinkWidth;
        else if (value == "PCIExpressLinkSpeed")
            return StatusID::PCIExpressLinkSpeed;
        else if (value == "LastVideoOutputPixelFormat")
            return StatusID::LastVideoOutputPixelFormat;
        else if (value == "ReferenceSignalMode")
            return StatusID::ReferenceSignalMode;
        else if (value == "DuplexMode")
            return StatusID::DuplexMode;
        else if (value == "BusyState")
            return StatusID::BusyState;
        else if (value == "VideoInputSignalLocked")
            return StatusID::VideoInputSignalLocked;
        else if (value == "ReferenceSignalLocked")
            return StatusID::ReferenceSignalLocked;
        else if (value == "ReferenceSignalFlags")
            return StatusID::ReferenceSignalFlags;

        throw std::out_of_range(value);
    }

    namespace StatusID_ {

        std::string get_description(StatusID value) {
            if (value == StatusID::DetectedVideoInputMode)
                return "The detected video input mode (BMDDisplayMode), available on devices which support input format detection.";
            else if (value == StatusID::DetectedVideoInputFlags)
                return "The detected video input flags (BMDDeckLinkVideoStatusFlags), available on devices which support input format detection.";
            else if (value == StatusID::CurrentVideoInputMode)
                return "The current video input mode (BMDDisplayMode).";
            else if (value == StatusID::CurrentVideoInputPixelFormat)
                return "The current video input pixel format (BMDPixelFormat).";
            else if (value == StatusID::CurrentVideoInputFlags)
                return "The current video input flags (BMDDeckLinkVideoStatusFlags)";
            else if (value == StatusID::CurrentVideoOutputMode)
                return "The current video output mode (BMDDisplayMode).";
            else if (value == StatusID::CurrentVideoOutputFlags)
                return "The current video output flags (BMDDeckLinkVideoStatusFlags).";
            else if (value == StatusID::PCIExpressLinkWidth)
                return "PCIe link width, x1, x4, etc.";
            else if (value == StatusID::PCIExpressLinkSpeed)
                return "PCIe link speed, Gen. 1, Gen. 2, etc.";
            else if (value == StatusID::LastVideoOutputPixelFormat)
                return "The last video output pixel format (BMDPixelFormat).";
            else if (value == StatusID::ReferenceSignalMode)
                return "The detected reference input mode (BMDDisplayMode), available on devices which support reference input format detection.";
            else if (value == StatusID::DuplexMode)
                return "The duplex status (BMDDuplexStatus) of the DeckLink device / sub-device.";
            else if (value == StatusID::BusyState)
                return "The current busy state of the device. (See BMDDeviceBusyState for more information).";
            else if (value == StatusID::VideoInputSignalLocked)
                return "True if the video input signal is locked.";
            else if (value == StatusID::ReferenceSignalLocked)
                return "True if the reference input signal is locked.";
            else if (value == StatusID::ReferenceSignalFlags)
                return "The detected reference input flags (BMDDeckLinkVideoStatusFlags), available on devices which support reference input format detection.";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<StatusID>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::InputFormatFlag value) {
    switch(value) {
    case DeckLink::InputFormatFlag::YCbCr422:
        return "YCbCr422";
    case DeckLink::InputFormatFlag::RGB444:
        return "RGB444";
    case DeckLink::InputFormatFlag::DualStream3D:
        return "DualStream3D";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::InputFormatFlag value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    InputFormatFlag to_InputFormatFlag(const std::string & value) {
        if (value == "YCbCr422")
            return InputFormatFlag::YCbCr422;
        else if (value == "RGB444")
            return InputFormatFlag::RGB444;
        else if (value == "DualStream3D")
            return InputFormatFlag::DualStream3D;

        throw std::out_of_range(value);
    }

    namespace InputFormatFlag_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::DisplayModeFlags value) {
    switch(value) {
    case DeckLink::DisplayModeFlags::Supports3D:
        return "Supports3D";
    case DeckLink::DisplayModeFlags::ColorspaceRec601:
        return "ColorspaceRec601";
    case DeckLink::DisplayModeFlags::ColorspaceRec709:
        return "ColorspaceRec709";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::DisplayModeFlags value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    DisplayModeFlags to_DisplayModeFlags(const std::string & value) {
        if (value == "Supports3D")
            return DisplayModeFlags::Supports3D;
        else if (value == "ColorspaceRec601")
            return DisplayModeFlags::ColorspaceRec601;
        else if (value == "ColorspaceRec709")
            return DisplayModeFlags::ColorspaceRec709;

        throw std::out_of_range(value);
    }

    namespace DisplayModeFlags_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::DisplayModeSupport value) {
    switch(value) {
    case DeckLink::DisplayModeSupport::NotSupported:
        return "NotSupported";
    case DeckLink::DisplayModeSupport::Supported:
        return "Supported";
    case DeckLink::DisplayModeSupport::SupportedWithConversion:
        return "SupportedWithConversion";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::DisplayModeSupport value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    DisplayModeSupport to_DisplayModeSupport(const std::string & value) {
        if (value == "NotSupported")
            return DisplayModeSupport::NotSupported;
        else if (value == "Supported")
            return DisplayModeSupport::Supported;
        else if (value == "SupportedWithConversion")
            return DisplayModeSupport::SupportedWithConversion;

        throw std::out_of_range(value);
    }

    namespace DisplayModeSupport_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::TimecodeFormat value) {
    switch(value) {
    case DeckLink::TimecodeFormat::RP188VITC1:
        return "RP188VITC1";
    case DeckLink::TimecodeFormat::RP188VITC2:
        return "RP188VITC2";
    case DeckLink::TimecodeFormat::RP188LTC:
        return "RP188LTC";
    case DeckLink::TimecodeFormat::RP188Any:
        return "RP188Any";
    case DeckLink::TimecodeFormat::VITC:
        return "VITC";
    case DeckLink::TimecodeFormat::VITCField2:
        return "VITCField2";
    case DeckLink::TimecodeFormat::Serial:
        return "Serial";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::TimecodeFormat value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    TimecodeFormat to_TimecodeFormat(const std::string & value) {
        if (value == "RP188VITC1")
            return TimecodeFormat::RP188VITC1;
        else if (value == "RP188VITC2")
            return TimecodeFormat::RP188VITC2;
        else if (value == "RP188LTC")
            return TimecodeFormat::RP188LTC;
        else if (value == "RP188Any")
            return TimecodeFormat::RP188Any;
        else if (value == "VITC")
            return TimecodeFormat::VITC;
        else if (value == "VITCField2")
            return TimecodeFormat::VITCField2;
        else if (value == "Serial")
            return TimecodeFormat::Serial;

        throw std::out_of_range(value);
    }

    namespace TimecodeFormat_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::TimecodeFlags value) {
    switch(value) {
    case DeckLink::TimecodeFlags::FlagDefault:
        return "FlagDefault";
    case DeckLink::TimecodeFlags::IsDropFrame:
        return "IsDropFrame";
    case DeckLink::TimecodeFlags::FieldMark:
        return "FieldMark";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::TimecodeFlags value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    TimecodeFlags to_TimecodeFlags(const std::string & value) {
        if (value == "FlagDefault")
            return TimecodeFlags::FlagDefault;
        else if (value == "IsDropFrame")
            return TimecodeFlags::IsDropFrame;
        else if (value == "FieldMark")
            return TimecodeFlags::FieldMark;

        throw std::out_of_range(value);
    }

    namespace TimecodeFlags_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::BusyState value) {
    switch(value) {
    case DeckLink::BusyState::NotBusy:
        return "NotBusy";
    case DeckLink::BusyState::CaptureBusy:
        return "CaptureBusy";
    case DeckLink::BusyState::PlaybackBusy:
        return "PlaybackBusy";
    case DeckLink::BusyState::SerialPortBusy:
        return "SerialPortBusy";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::BusyState value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    BusyState to_BusyState(const std::string & value) {
        if (value == "NotBusy")
            return BusyState::NotBusy;
        else if (value == "CaptureBusy")
            return BusyState::CaptureBusy;
        else if (value == "PlaybackBusy")
            return BusyState::PlaybackBusy;
        else if (value == "SerialPortBusy")
            return BusyState::SerialPortBusy;

        throw std::out_of_range(value);
    }

    namespace BusyState_ {

        std::string get_description(BusyState value) {
            if (value == BusyState::NotBusy)
                return "The device is not currently in use";
            else if (value == BusyState::CaptureBusy)
                return "The device is currently being used for capture.";
            else if (value == BusyState::PlaybackBusy)
                return "The device is currently being used for playback.";
            else if (value == BusyState::SerialPortBusy)
                return "The device’s serial port is currently being used.";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<BusyState>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::InputFormatChangedEvent value) {
    switch(value) {
    case DeckLink::InputFormatChangedEvent::DisplayModeChanged:
        return "DisplayModeChanged";
    case DeckLink::InputFormatChangedEvent::FieldDominanceChanged:
        return "FieldDominanceChanged";
    case DeckLink::InputFormatChangedEvent::ColorspaceChanged:
        return "ColorspaceChanged";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::InputFormatChangedEvent value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    InputFormatChangedEvent to_InputFormatChangedEvent(const std::string & value) {
        if (value == "DisplayModeChanged")
            return InputFormatChangedEvent::DisplayModeChanged;
        else if (value == "FieldDominanceChanged")
            return InputFormatChangedEvent::FieldDominanceChanged;
        else if (value == "ColorspaceChanged")
            return InputFormatChangedEvent::ColorspaceChanged;

        throw std::out_of_range(value);
    }

    namespace InputFormatChangedEvent_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::DetectedVideoInputFormatFlags value) {
    switch(value) {
    case DeckLink::DetectedVideoInputFormatFlags::YCbCr422:
        return "YCbCr422";
    case DeckLink::DetectedVideoInputFormatFlags::RGB444:
        return "RGB444";
    case DeckLink::DetectedVideoInputFormatFlags::DualStream3D:
        return "DualStream3D";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::DetectedVideoInputFormatFlags value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    DetectedVideoInputFormatFlags to_DetectedVideoInputFormatFlags(const std::string & value) {
        if (value == "YCbCr422")
            return DetectedVideoInputFormatFlags::YCbCr422;
        else if (value == "RGB444")
            return DetectedVideoInputFormatFlags::RGB444;
        else if (value == "DualStream3D")
            return DetectedVideoInputFormatFlags::DualStream3D;

        throw std::out_of_range(value);
    }

    namespace DetectedVideoInputFormatFlags_ {

        std::string pretty_print(DetectedVideoInputFormatFlags value) {
            if (value == DetectedVideoInputFormatFlags::YCbCr422)
                return "YCbCr 4:2:2";
            else if (value == DetectedVideoInputFormatFlags::RGB444)
                return "RGB 4:4:4";
            else if (value == DetectedVideoInputFormatFlags::DualStream3D)
                return "Dual Stream 3D";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<DetectedVideoInputFormatFlags>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::DuplexMode value) {
    switch(value) {
    case DeckLink::DuplexMode::Full:
        return "Full";
    case DeckLink::DuplexMode::Half:
        return "Half";
    case DeckLink::DuplexMode::Simplex:
        return "Simplex";
    case DeckLink::DuplexMode::Inactive:
        return "Inactive";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::DuplexMode value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    DuplexMode to_DuplexMode(const std::string & value) {
        if (value == "Full")
            return DuplexMode::Full;
        else if (value == "Half")
            return DuplexMode::Half;
        else if (value == "Simplex")
            return DuplexMode::Simplex;
        else if (value == "Inactive")
            return DuplexMode::Inactive;

        throw std::out_of_range(value);
    }

    namespace DuplexMode_ {

        std::string get_description(DuplexMode value) {
            if (value == DuplexMode::Full)
                return "Capable of simultaneous playback and capture.";
            else if (value == DuplexMode::Half)
                return "Capable of playback or capture but not both simultaneously.";
            else if (value == DuplexMode::Simplex)
                return "Capable of playback only or capture only..";
            else if (value == DuplexMode::Inactive)
                return "Device is inactive.";
    
            throw std::out_of_range(
                std::to_string(
                    static_cast<std::underlying_type<DuplexMode>::type>(value)
                )
            );
        }
    

    }

} // end namespace DeckLink

std::string to_string(DeckLink::HResult value) {
    switch(value) {
    case DeckLink::HResult::Ok:
        return "Ok";
    case DeckLink::HResult::False:
        return "False";
    case DeckLink::HResult::Unexpected:
        return "Unexpected";
    case DeckLink::HResult::NotImplemented:
        return "NotImplemented";
    case DeckLink::HResult::OutOfMemory:
        return "OutOfMemory";
    case DeckLink::HResult::InvalidArg:
        return "InvalidArg";
    case DeckLink::HResult::NoInterface:
        return "NoInterface";
    case DeckLink::HResult::Pointer:
        return "Pointer";
    case DeckLink::HResult::Handle:
        return "Handle";
    case DeckLink::HResult::Abort:
        return "Abort";
    case DeckLink::HResult::Fail:
        return "Fail";
    case DeckLink::HResult::AccessDenied:
        return "AccessDenied";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::HResult value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    HResult to_HResult(const std::string & value) {
        if (value == "Ok")
            return HResult::Ok;
        else if (value == "False")
            return HResult::False;
        else if (value == "Unexpected")
            return HResult::Unexpected;
        else if (value == "NotImplemented")
            return HResult::NotImplemented;
        else if (value == "OutOfMemory")
            return HResult::OutOfMemory;
        else if (value == "InvalidArg")
            return HResult::InvalidArg;
        else if (value == "NoInterface")
            return HResult::NoInterface;
        else if (value == "Pointer")
            return HResult::Pointer;
        else if (value == "Handle")
            return HResult::Handle;
        else if (value == "Abort")
            return HResult::Abort;
        else if (value == "Fail")
            return HResult::Fail;
        else if (value == "AccessDenied")
            return HResult::AccessDenied;

        throw std::out_of_range(value);
    }

    namespace HResult_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::CaptureDelegateError value) {
    switch(value) {
    case DeckLink::CaptureDelegateError::Ok:
        return "Ok";
    case DeckLink::CaptureDelegateError::EmptyFrameReceived:
        return "EmptyFrameReceived";
    case DeckLink::CaptureDelegateError::EmptyVideoStream:
        return "EmptyVideoStream";
    case DeckLink::CaptureDelegateError::PixelFormatConversionError:
        return "PixelFormatConversionError";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::CaptureDelegateError value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    CaptureDelegateError to_CaptureDelegateError(const std::string & value) {
        if (value == "Ok")
            return CaptureDelegateError::Ok;
        else if (value == "EmptyFrameReceived")
            return CaptureDelegateError::EmptyFrameReceived;
        else if (value == "EmptyVideoStream")
            return CaptureDelegateError::EmptyVideoStream;
        else if (value == "PixelFormatConversionError")
            return CaptureDelegateError::PixelFormatConversionError;

        throw std::out_of_range(value);
    }

    namespace CaptureDelegateError_ {


    }

} // end namespace DeckLink

std::string to_string(DeckLink::VideoInputError value) {
    switch(value) {
    case DeckLink::VideoInputError::NullFrame:
        return "NullFrame";
    case DeckLink::VideoInputError::NoInputSource:
        return "NoInputSource";

    default: return "Unknown Value";
    }
}


std::ostream& operator<<(std::ostream& os, const DeckLink::VideoInputError value) {
    os << to_string(value);
    return os;
}

namespace DeckLink {

    VideoInputError to_VideoInputError(const std::string & value) {
        if (value == "NullFrame")
            return VideoInputError::NullFrame;
        else if (value == "NoInputSource")
            return VideoInputError::NoInputSource;

        throw std::out_of_range(value);
    }

    namespace VideoInputError_ {


    }

} // end namespace DeckLink
